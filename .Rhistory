data <- read.csv("data/energy_flexibility_data.csv")
summary(data)
View(data)
View(data)
df <- read.csv("data/energy_flexibility_data.csv", stringsAsFactors = FALSE)
summary(data)
time_col <- "timestamp"
df[["timestamp"]] <-as.POSIXct(df[["timestamp", tz="UTC"]])
df[[time_col]] <-as.POSIXct(df[[time_col, tz="UTC"]])
df[[time_col]] <-as.POSIXct(df[[time_col]], tz="UTC")
cat("Rows: ", nrows(df), "\n", "Columns: ", ncol(df), "\n")
cat("Rows: ", nrow(df), "\n", "Columns: ", ncol(df), "\n")
cat("Rows: ", nrow(df), "Columns: ", ncol(df), "\n")
cat("Rows: ", nrow(df),"\n", "Columns: ", ncol(df), "\n")
cat("Time Range: ")
print(range(df[[time_col]], na.rm= TRUE ))
cat("Missing Values per column:")
print(colSums(is.na(df)))
dt_min <- as.numeric(diff(df[[time_col]]))/60
print(summary(dt_min))
print(dt_min)
print(head(dt_min))
cat("\nMost common time steps (minutes):\n")
print(sort(table(dt_min), decreasing = TRUE)[1:10])
# Find gaps that are not 15 minutes
gap_idx <- which(dt_min != 15)
length(gap_idx)
cat("\nFirst few gaps:\n")
gaps <- data.frame(
t_prev = df[[time_col]][gap_idx],
t_next = df[[time_col]][gap_idx + 1],
step_min = dt_min[gap_idx]
)
print(head(gaps, 10))
# Find gaps that are not 15 minutes
gap_idx <- which(dt_min != 25)
length(gap_idx)
plot(df[[time_col]], df$Refrigerator_kW, type = "l",
xlab = "Time", ylab = "kW",
main = "Refrigerator_kW over full period")
diff(df[[time_col]])[1]
diff(df[[time_col]][-nrow(df)])
dt_min <- as.numeric(diff(df[[time_col]], units = "mins")
print(head(dt_min))
dt_min <- as.numeric(diff(df[[time_col]]), units = "mins")
print(dt_min)
print(summary(dt_min))
# Find gaps that are not 15 minutes
gap_idx <- which(dt_min != 15)
length(gap_idx)
plot(df[[time_col]], df$Refrigerator_kW, type = "l",
xlab = "Time", ylab = "kW",
main = "Refrigerator_kW over full period")
appliance_cols <- c("Refrigerator_kW",
"WashingMachine_kW",
"Dishwasher_kW",
"Dryer_kW",
"WaterHeater_kW")
par(mfrow = c(3, 2))  # 3 rows, 2 columns
for (col in appliance_cols) {
plot(df$timestamp, df[[col]],
type = "l",
xlab = "Time",
ylab = "kW",
main = col)
}
par(mfrow = c(1, 1))  # reset layout
df <- arrange(df, timestamp)
library(dplyr)
library(lubridate)
library(tidyr)
df <- read.csv("data/energy_flexibility_data.csv", stringsAsFactors = FALSE)
time_col <- "timestamp"
df$timestamp <- ymd_hms(df$timestamp, tz="UTC")
df <- arrange(df, timestamp)
# Basic data-frame checks
str(df)
summary(df)
appliances <- setdiff(names(df), "timestamp")
plot(df$timestamp, df[[col]],
type = "l",
xlab = "Time",
ylab = "kW",
main = col)
for (col in appliances) {
plot(df$timestamp, df[[col]],
type = "l",
xlab = "Time",
ylab = "kW",
main = col)
}
par(mfrow = c(1, 1))  # reset layout
for (col in appliances) {
plot(df$timestamp, df[[col]],
type = "l",
xlab = "Time",
ylab = "kW",
main = col)
}
par(mfrow = c(3, 2))  # 3 rows, 2 columns
for (col in appliances) {
plot(df$timestamp, df[[col]],
type = "l",
xlab = "Time",
ylab = "kW",
main = col)
}
par(mfrow = c(1, 1))  # reset layout
df <- df |> mutate(date = as.Date(timestamp),
hour = hour(timestamp),
wday = wday(timestamp, label = TRUE))
head(df)
#check for missing colums:
colSums(is.na(df))
daily_energy <- df |> group_by(date) |>
summarise(across(all_of(appliacnces),
~ sum(.x * dt_h, na.rm = TRUE),
.names = "{.col}_kWh"))
daily_energy <- df |> group_by(date) |>
summarise(across(all_of(appliances),
function(x) sum(x * dt_h, na.rm = TRUE),
.names = "{.col}_kWh"))
#daily energy per appliance:
dt_h <- 0.25
daily_energy <- df |> group_by(date) |>
summarise(across(all_of(appliances),
function(x) sum(x * dt_h, na.rm = TRUE),
.names = "{.col}_kWh"))
daily_energy
X <- daily_energy |> select(-date)
cor_mat <- cor(X, use="pairwise.complete.obs", method = "pearson")
corrplot(cor_mat, method = "circle", type = "upper")
library(corrplot)
library(corrplot)
heatmap(cor_mat,
symm = TRUE,
margins = c(6, 6))
install.packages("corrplot")
library(corrplot)
corrplot(cor_mat, method = "circle", type = "upper")corrplot(cor_mat, method = "circle", type = "upper")
corrplot(cor_mat, method = "circle", type = "upper")
library(dplyr)
library(lubridate)
library(tidyr)
library(corrplot)
df <- read.csv("data/energy_flexibility_data.csv", stringsAsFactors = FALSE)
time_col <- "timestamp"
df$timestamp <- ymd_hms(df$timestamp, tz="UTC")
df <- arrange(df, timestamp)
# Basic data-frame checks
str(df)
summary(df)
appliances <- setdiff(names(df), "timestamp")
par(mfrow = c(3, 2))  # 3 rows, 2 columns
for (col in appliances) {
plot(df$timestamp, df[[col]],
type = "l",
xlab = "Time",
ylab = "kW",
main = col)
}
par(mfrow = c(1, 1))  # reset layout
df <- df |> mutate(date = as.Date(timestamp),
hour = hour(timestamp),
wday = wday(timestamp, label = TRUE))
head(df)
#check for missing colums:
colSums(is.na(df))
#daily energy per appliance:
dt_h <- 0.25
daily_energy <- df |> group_by(date) |>
summarise(across(all_of(appliances),
function(x) sum(x * dt_h, na.rm = TRUE),
.names = "{.col}_kWh"))
daily_energy
X <- daily_energy |> select(-date)
cor_mat <- cor(X, use="pairwise.complete.obs", method = "pearson")
heatmap(cor_mat,
symm = TRUE,
margins = c(6, 6))
corrplot(cor_mat, method = "circle", type = "upper")
daily_energy <- df |> group_by(date) |>
summarise(across(all_of(appliances),
function(x) sum(x * dt_h, na.rm = TRUE),
.names = "{sub('_kW','',.col)}_daily_kWh"))
daily_energy
X <- daily_energy |> select(-date)
cor_mat <- cor(X, use="pairwise.complete.obs", method = "pearson")
heatmap(cor_mat,
symm = TRUE,
margins = c(6, 6))
corrplot(cor_mat, method = "circle", type = "upper")
.names="{.col}_{.fn}"))
.names="{.col}_{.fn}")
# load factor summary
load_stats <- df|> summarise(across(all_of(appliances),
list(mean = ~mean(.x, na.rm= TRUE),
max = ~max(.x, na.rm= TRUE),
p95 =~quantile(.x, 0.95, na.rm= TRUE)),
.names="{.col}_{.fn}"))
load_stats
source("~/Documents/DAMA/DAMA51/energy-flexibility-proj/scripts/DataUnderstanding.R")
load_stats_table <- load_stats |> pivot_longer(
cols = everything(),
names_to = c("Appliance", ".value"),
names_sep = "_(?=[^_]+$)")
load_stats_table
load_stats_table <- load_stats |> pivot_longer(
cols = all_of(appliances),
names_to = "Appliance",
values_to = "kW") |>
group_by(Appliance) |>
summarise(
mean = mean(kW, na.rm= TRUE),
max = max(kW, na.rm= TRUE),
p95 =~quantile(kW, 0.95, na.rm= TRUE))
load_stats_table <- load_stats |> pivot_longer(
cols = all_of(appliances),
names_to = "Appliance",
values_to = "kW") |>
group_by(Appliance) |>
summarise(
mean = mean(kW, na.rm= TRUE),
max = max(kW, na.rm= TRUE),
p95 =~quantile(kW, 0.95, na.rm= TRUE))
# load factor summary
load_stats_table <- df |>
select(all_of(appliances)) |>
pivot_longer(
cols = everything(),
names_to = "Appliance",
values_to = "kW"
) |>
group_by(Appliance) |>
summarise(
mean = mean(kW, na.rm = TRUE),
max  = max(kW, na.rm = TRUE),
p95  = quantile(kW, 0.95, na.rm = TRUE)
)
load_stats_table
pca <- prcomp(X, center = TRUE, scale. = TRUE)
summary(pca)
pca$rotation[, 1:3]   # loadings: which appliances drive PC1/PC2
